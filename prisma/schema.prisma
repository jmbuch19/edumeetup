generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User & Auth Models (Standard Auth.js / NextAuth)

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  role          UserRole  @default(STUDENT)
  isActive      Boolean   @default(true)
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts      Account[]
  sessions      Session[]
  
  // Relations to Profiles
  student       Student?
  university    University?
  
  // Relations to Features
  supportTickets    SupportTicket[]
  notifications     Notification[]

  auditLogs         AuditLog[]
  availabilityProfiles AvailabilityProfile[] @relation("RepAvailability")
  meetings          Meeting[]             @relation("RepMeetings")
  meetingNotifications MeetingNotification[]
  advisedRequests   AdvisoryRequest[] @relation("AdviserRequests")
  meetingParticipations MeetingParticipant[]
  availabilitySlots     AvailabilitySlot[]
}

model Account {
  id                 String  @id @default(cuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String? @db.Text
  access_token       String? @db.Text
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String? @db.Text
  session_state      String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Domain Models

model Student {
  id                String   @id @default(cuid())
  userId            String   @unique
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Contact & Location
  phone             String?
  city              String?
  pincode           String?
  country           String?  @default("India")
  
  // IP Tracking & Verification
  ipAddress         String?
  ipCity            String?
  ipRegion          String?
  ipCountry         String?
  ipPincode         String?
  ipLatitude        String?
  ipLongitude       String?
  ipIsp             String?
  
  cityMismatch      Boolean  @default(false)
  pincodeMismatch   Boolean  @default(false)

  // Preserved Profile Fields (Critical for App Functionality)
  fullName          String? // Can sync with User.name
  gender            String?
  ageGroup          String?
  currentStatus     String?
  fieldOfInterest   String?
  preferredCountries String?
  preferredDegree   String?
  budgetRange       String?
  englishTestType   String?
  englishScore      String?
  preferredIntake   String?
  profileComplete   Boolean  @default(false)
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  interests         Interest[]
  advisoryRequests  AdvisoryRequest[]
  meetings          Meeting[]
  bookmarks         Bookmark[]
  eventRegistrations EventRegistration[]
}

model University {
  id                String    @id @default(cuid())
  userId            String    @unique
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  institutionName   String      // Renamed from universityName to match code usage
  country           String
  city              String?
  website           String?
  accreditationNo   String?
  
  verificationStatus String   @default("PENDING") // Added to match code usage
  isVerified        Boolean   @default(false)
  verifiedAt        DateTime?
  verifiedByAdmin   String?
  
  // Preserved Fields
  contactEmail      String?
  logo              String?
  about             String?   @db.Text
  foundedYear       Int?
  campusSize        String?
  totalStudents     Int?
  internationalStudents Int?
  
  // Rep Details (Merged from old schema)
  repName           String?
  repDesignation    String?
  repEmail          String?
  contactPhone      String?
  
  // Features
  scholarshipsAvailable Boolean @default(false)
  meetingLink       String?
  
  // Certification
  certAuthority     Boolean   @default(false)
  certLegitimacy    Boolean   @default(false)
  certPurpose       Boolean   @default(false)
  certAccountability Boolean  @default(false)
  certTimestamp     DateTime?
  certIp            String?

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  programs          Program[]
  interests         Interest[]
  meetings          Meeting[]
  availabilityProfiles AvailabilityProfile[]
  hostOutreach      HostRequestOutreach[]
  bookmarkedBy      Bookmark[]
  availabilitySlots AvailabilitySlot[]
  events            Event[]
}

model Program {
  id             String      @id @default(cuid())
  universityId   String
  university     University  @relation(fields: [universityId], references: [id], onDelete: Cascade)
  
  programName    String
  degreeLevel    String
  fieldCategory  String
  durationMonths Int?        // Renamed from duration to match code if needed, but let's check code usage.
  tuitionFee     Float?
  currency       String?     @default("USD")
  
  // Preserved fields
  status         String      @default("ACTIVE")
  stemDesignated Boolean     @default(false)
  englishTests   String?
  minEnglishScore Float?
  intakes        String?
  description    String?     @db.Text
  
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  interests      Interest[]
  meetings       Meeting[]
}

// Enums

enum UserRole {
  STUDENT
  UNIVERSITY
  ADMIN
}

// Feature Models (Updated to use new Student/University relations)

model Interest {
  id             String      @id @default(cuid())
  studentId      String
  student        Student     @relation(fields: [studentId], references: [id], onDelete: Cascade)
  universityId   String
  university     University  @relation(fields: [universityId], references: [id], onDelete: Cascade)
  programId      String?
  program        Program?    @relation(fields: [programId], references: [id], onDelete: Cascade)
  status         String      @default("INTERESTED")
  studentMessage String?
  universityNote String?
  
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  @@unique([studentId, universityId, programId])
}





model Notification {
  id             String      @id @default(cuid())
  userId         String
  user           User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  type           String
  title          String
  message        String
  payload        Json?
  isRead         Boolean     @default(false)
  
  createdAt      DateTime    @default(now())
}



model AuditLog {
  id        String   @id @default(cuid())
  action    String
  entityType String
  entityId  String
  actorId   String
  actor     User     @relation(fields: [actorId], references: [id])
  metadata  Json?
  createdAt DateTime @default(now())
}

model AdvisoryRequest {
  id            String   @id @default(cuid())
  studentId     String
  student       Student  @relation(fields: [studentId], references: [id], onDelete: Cascade)

  targetDegree  String?
  fieldOfInterest String?
  targetCountry String?
  budgetRange   String?
  englishScore  String?
  greGmatScore  String?
  preferredTime String?
  targetIntake  String?
  openQuestion  String?  @db.Text

  status        AdvisoryStatus @default(NEW)
  adviserId     String?
  adviser       User?    @relation("AdviserRequests", fields: [adviserId], references: [id], onDelete: SetNull)
  
  internalNotes String?  @db.Text
  sessionLink   String?

  createdAt     DateTime @default(now())
  completedAt   DateTime?
}

// Preserve Enums for Feature Compatibility
enum FieldCategory {
  Computer_Science  @map("Computer Science")
  Engineering
  Business
  Data_Science      @map("Data Science")
  Health_Sciences   @map("Health Sciences")
  Social_Sciences   @map("Social Sciences")
  Arts_Humanities   @map("Arts & Humanities")
  Law
  Architecture
  Others
}

enum InquiryStatus {
  NEW
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
}

enum TicketType {
  STUDENT
  UNIVERSITY
}

model PublicInquiry {
  id        String   @id @default(cuid())
  fullName  String
  email     String
  role      String
  country   String
  subject   String
  message   String
  phone     String?
  orgName   String?
  status    InquiryStatus @default(NEW)
  createdAt DateTime @default(now())
}

model SupportTicket {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  type      TicketType
  category  String
  priority  TicketPriority
  message   String
  status    InquiryStatus @default(NEW)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum AdvisoryStatus {
  NEW
  ASSIGNED
  SCHEDULED
  COMPLETED
  FOLLOW_UP
}

// Host Campus Fair Features

model HostRequest {
  id                String   @id @default(cuid())
  referenceNumber   String   @unique // HCF-YYYY-XXX

  // Institution Information
  institutionName   String
  institutionType   String   // UNIVERSITY, COLLEGE, SCHOOL
  city              String
  state             String
  websiteUrl        String

  // Contact Information
  contactName       String
  contactDesignation String
  contactEmail      String
  contactPhone      String

  // Event Requirements
  preferredDateStart DateTime
  preferredDateEnd   DateTime
  expectedStudentCount String // 50-100, 100-250, etc.

  // Preferences (Stored as JSON for flexibility)
  preferredCountries Json     // ["USA", "UK"]
  fieldsOfStudy      Json     // ["Engineering", "Business"]
  additionalRequirements String? @db.Text

  // Workflow Status
  status            String   @default("SUBMITTED") // SUBMITTED, APPROVED, OUTREACH_SENT, COMPLETED, CANCELLED

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  outreach          HostRequestOutreach[]
}

model HostRequestOutreach {
  id                String      @id @default(cuid())
  
  hostRequestId     String
  hostRequest       HostRequest @relation(fields: [hostRequestId], references: [id], onDelete: Cascade)

  universityId      String
  university        University  @relation(fields: [universityId], references: [id], onDelete: Cascade)

  status            String      @default("SENT") // SENT, INTERESTED, NOT_INTERESTED
  
  sentAt            DateTime    @default(now())
  respondedAt       DateTime?
  responseNote      String?     @db.Text
  
  @@unique([hostRequestId, universityId])
  @@index([hostRequestId])
  @@index([universityId])
}

// -----------------------------------------------------------------------------
// MEETING SYSTEM MODELS (New Implementation)
// -----------------------------------------------------------------------------

enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

enum VideoProvider {
  GOOGLE_MEET
  ZOOM
  EXTERNAL_LINK
}

enum MeetingStatus {
  DRAFT
  PENDING
  CONFIRMED
  RESCHEDULE_PROPOSED
  CANCELLED
  COMPLETED
  NO_SHOW
}

enum MeetingPurpose {
  ADMISSION_QUERY
  PROGRAM_FIT
  SCHOLARSHIP_INFO
  DOCUMENT_HELP
  APPLICATION_STATUS
  OTHER
}

// Stores recurring availability rules (e.g., "Mondays 9am-5pm")
model AvailabilityProfile {
  id             String        @id @default(cuid())
  
  universityId   String
  university     University    @relation(fields: [universityId], references: [id], onDelete: Cascade)
  
  repId          String        // The specific user (rep) this schedule belongs to
  repUser        User          @relation("RepAvailability", fields: [repId], references: [id], onDelete: Cascade)

  // Schedule Rules
  dayOfWeek      DayOfWeek
  startTime      String        // "09:00" (24h format)
  endTime        String        // "17:00" (24h format)
  isActive       Boolean       @default(true)

  // Configuration
  meetingDurationOptions Int[] // [10, 15, 20]
  bufferMinutes          Int   @default(10)
  minLeadTimeHours       Int   @default(12)
  dailyCap               Int   @default(8)

  // Video Settings
  videoProvider      VideoProvider @default(GOOGLE_MEET)
  externalLink       String?       // Used if provider is EXTERNAL_LINK

  // Filters
  eligibleDegreeLevels String[]    // ["UG", "Grad", "PhD"]
  eligibleCountries    String[]    // ["India", "USA", etc.]

  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  @@index([universityId])
  @@index([repId])
}

model Meeting {
  id              String        @id @default(cuid())
  
  // Participants
  studentId       String?
  student         Student?       @relation(fields: [studentId], references: [id], onDelete: Cascade)
  
  universityId    String
  university      University?    @relation(fields: [universityId], references: [id], onDelete: Cascade)

  repId           String?
  rep             User?          @relation("RepMeetings", fields: [repId], references: [id], onDelete: Cascade)

  programId       String?
  program         Program?      @relation(fields: [programId], references: [id])

  title           String?
  agenda          String?       @db.Text
  meetingType     String?
  joinUrl         String?
  availabilitySlot AvailabilitySlot?

  // Content & Purpose
  purpose         MeetingPurpose
  studentQuestions String?      @db.Text // Bullet points, max 1000 chars
  uploadedDocUrl   String?      // Logic handled via uploadthing or similar
  
  // Scheduling
  durationMinutes Int           // 10, 15, 20
  startTime       DateTime      // UTC
  endTime         DateTime      // UTC
  
  studentTimezone String
  repTimezone     String

  // Status Workflow
  status          MeetingStatus @default(PENDING)
  
  // Video & Access
  videoProvider   VideoProvider
  videoLink       String?
  meetingCode     String        // "EDU-2025-XXXXX"

  // Cancellation / Reschedule
  cancellationReason     String?
  cancelledBy            String? // "STUDENT", "UNIVERSITY", "SYSTEM"
  cancelledAt            DateTime?
  isLateCancel           Boolean   @default(false)
  
  rescheduleProposedBy   String? // "STUDENT", "UNIVERSITY"
  rescheduleProposedTime DateTime? 

  // Post-Meeting
  universityNotes       String?   @db.Text // Private
  studentNotes          String?   @db.Text // Private to student
  studentRating         Int?
  universityRating      Int?

  // Notifications
  reminder24hSent       Boolean   @default(false)
  reminder1hSent        Boolean   @default(false)
  reminder10minSent     Boolean   @default(false)

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  notifications   MeetingNotification[]

  @@index([studentId])
  @@index([universityId])
  @@index([repId])
  @@index([status])

  participants    MeetingParticipant[]
}

model MeetingParticipant {
  id                String   @id @default(cuid())
  meetingId         String
  meeting           Meeting  @relation(fields: [meetingId], references: [id], onDelete: Cascade)
  participantUserId String
  user              User     @relation(fields: [participantUserId], references: [id], onDelete: Cascade)
  participantType   String   @default("STUDENT") // STUDENT, UNIVERSITY, etc.
  rsvpStatus        String   @default("INVITED")
  joinedAt          DateTime?
  
  @@unique([meetingId, participantUserId])
  @@index([participantUserId])
  @@index([meetingId])
}

model MeetingNotification {
  id              String   @id @default(cuid())
  
  meetingId       String
  meeting         Meeting  @relation(fields: [meetingId], references: [id], onDelete: Cascade)
  
  recipientId     String
  recipient       User     @relation(fields: [recipientId], references: [id], onDelete: Cascade)

  type            String   // "BOOKED", "CONFIRMED", "REMINDER_1H", etc.
  channel         String   // "EMAIL", "IN_APP"
  
  sentAt          DateTime @default(now())
  delivered       Boolean  @default(false)
  contentPreview  String?

  @@index([meetingId])
  @@index([recipientId])
}

model AvailabilitySlot {
  id             String    @id @default(cuid())
  universityId   String
  university     University @relation(fields: [universityId], references: [id], onDelete: Cascade)
  repId          String
  repUser        User       @relation(fields: [repId], references: [id], onDelete: Cascade)
  
  startTime      DateTime
  endTime        DateTime
  isBooked       Boolean   @default(false)
  
  meetingId      String?   @unique
  meeting        Meeting?  @relation(fields: [meetingId], references: [id])
  
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@index([universityId])
  @@index([repId])
}

model Bookmark {
  id             String      @id @default(cuid())
  
  studentId      String
  student        Student     @relation(fields: [studentId], references: [id], onDelete: Cascade)
  
  universityId   String
  university     University  @relation(fields: [universityId], references: [id], onDelete: Cascade)

  note           String?
  
  createdAt      DateTime    @default(now())
  
  @@unique([studentId, universityId])
}

model Event {
  id          String   @id @default(cuid())
  universityId String
  university  University @relation(fields: [universityId], references: [id], onDelete: Cascade)
  title       String
  description String   @db.Text
  dateTime    DateTime
  location    String
  type        String   // 'WEBINAR', 'CAMPUS_TOUR', etc.
  capacity    Int?
  isPublished Boolean  @default(false)
  status      String   @default("UPCOMING")
  
  registrations EventRegistration[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model EventRegistration {
  id        String   @id @default(cuid())
  eventId   String
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  studentId String
  student   Student  @relation(fields: [studentId], references: [id], onDelete: Cascade)
  status    String   @default("REGISTERED")
  
  createdAt DateTime @default(now())
  
  @@unique([eventId, studentId])
}

model SystemLog {
  id        String   @id @default(cuid())
  level     String   // ERROR, WARN, INFO
  type      String   // EMAIL_FAILURE, APP_CRASH, etc.
  message   String
  metadata  Json?
  createdAt DateTime @default(now())
  
  @@index([type])
  @@index([level])
}
